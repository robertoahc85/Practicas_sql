

########################## demo-09-Transactions ##########################

# (Initial set up behind the scenes - no need to record)

# Open up two query editors, right-click and rename them "Session A" and "Session B"

# In the "Session A" editor paste this on top and have it be there for the entire demo (this way it will be easy to tell when you are working on session A and session B - this is just a comment in SQL)

----------------------------
-- Session A
----------------------------

# In the "Session B" editor paste this on top and have it be there for the entire demo

----------------------------
-- Session B
----------------------------


## IMPORTANT: Make the query window taller and the results window shorter so longer queries are visible


# Now start recording

-------------------------------------------------------------------------------------------------------------
Part 1 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


###--------- Session A

# Let’s create a new table called bank_accounts

CREATE TABLE bank_accounts (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    balance INT NOT NULL,
    PRIMARY KEY(id)
);

# Insert values to the table

INSERT INTO bank_accounts(name, balance) 
VALUES('Charlie', 10000);

INSERT INTO bank_accounts(name, balance)
VALUES('Dora', 25000);

SELECT * FROM bank_accounts;


# PostgreSQL inserted a new row into the accounts table immediately. 



# IMPORTANT: Click on the drop down next to the "run" button that we use to run commands and show that "Auto commit"
# is checked





-------------------------------------------------------------------------------------------------------------
Part 2 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

# Performing a sequence of steps that needs to be done atomically in a transaction

# A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block.

# Paste all the commands for Session A in and execute them in one go (no need to execute one-by-one)

## ----- Session A


BEGIN;

UPDATE bank_accounts
SET balance = balance - 100
WHERE name = 'Charlie';

UPDATE bank_accounts
SET balance = balance + 100
WHERE name = 'Dora';

COMMIT;

SELECT * FROM bank_accounts;


# Note that the amounts have been debited and credited atomically

# "Charlie" 9900
# "Dora"  25100


-------------------------------------------------------------------------------------------------------------
Part 3 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


# Rolling back a transaction

# Paste both commands in at one go and execute both at one go


## ----- Session A

INSERT INTO bank_accounts(name, balance)
VALUES('Jack', 1000);

SELECT * FROM bank_accounts;


# Should see 3 records in the database Charlie, Dora, and Jack


## ----- Session A


# Rollback a transaction

# Paste all the commands below so they can be seen in the same window

# Select one command at a time and execute using F5


BEGIN;

UPDATE bank_accounts
SET balance = balance - 1500
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 1500
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;


# At the end should see 3 records

# "Charlie" 9900
# "Dora"  25100
# "Jack"  1000



-------------------------------------------------------------------------------------------------------------
Part 4 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


# Rolling back a committed transaction

# Paste all the commands below so they can be seen in the same window

# Select one command at a time and execute using F5


## ----- Session A

BEGIN;

UPDATE bank_accounts
SET balance = balance - 900
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 900
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

COMMIT;

ROLLBACK;

SELECT * FROM bank_accounts;


# The rollback command should give you a warning, no transaction in progress

# The table will also have the updates made

# Ie, we cannot rollback a committed transaction


-------------------------------------------------------------------------------------------------------------
Part 5 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

# Savepoints

# Paste all the commands below so they can be seen in the same window

# Select one command at a time and execute using F5


## ----- Session A


BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Julia', 100000);

SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance - 2000
WHERE name = 'Julia';

UPDATE bank_accounts
SET balance = balance + 2000
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

ROLLBACK TO SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;


# After rolling back to the savepoint you should be able to see Julia in the bank_accounts

# After rolling back completely you should see only the original 3 records Charlie, Dora, Jack



-------------------------------------------------------------------------------------------------------------
Part 6 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

# Transaction isolation levels READ COMMITTED by default

# Here we will use both Session A and Session B


# Paste both commands in - then select each command and run using F5

# First only select BEGIN and the INSERT COMMAND and run

BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Nancy', 15000);


# Run in the current session (you should be able to see the record for Nancy)

SELECT * FROM bank_accounts;


## ----- Session B

# You should not be able to see the record for Nancy

SELECT * FROM bank_accounts;


## ----- Session A

# Commit the transaction

COMMIT;


## ----- Session B

# After commit you should now be able to see the record for Nancy

SELECT * FROM bank_accounts;


-------------------------------------------------------------------------------------------------------------
Part 7 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


## REPEATABLE READ



## ----- Session A
# Paste both commands in and just hit the play button to run all


BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;

SELECT * FROM bank_accounts;


# We see the data present


## ----- Session B
# Paste in all commands and just hit the play button to execute all


BEGIN;

UPDATE bank_accounts 
SET balance = 10000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;


# The balance for Jack should be 10000


## ----- Session A
# Execute the commands by selecting and running one at a time


SELECT * FROM bank_accounts;

COMMIT;


# Multiple reads in the same transaction got different results 


--------


# To avoid this we can use repeatable read isolation level

## ----- Session A
# Paste both commands in and just hit the play button to run all

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT * FROM bank_accounts;

# We see the balance is now 10000 for Jack


## ----- Session B
# Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 20000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;

# We see the balance is now 20000 for Jack



## ----- Session A

# Add this command to the bottom, select it and hit F5


SELECT * FROM bank_accounts;

# We see the balance did not change in Session A tt is still 10000 for Jack

# Now let's commit and see in Session A

# Paste both commands, select both, and run both


COMMIT;

SELECT * FROM bank_accounts;

# We see now the balance is changed to 20000



-------------------------------------------------------------------------------------------------------------
Part 8 ---------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------


## SERIALIZABLE
# Concurrent changes should be blocked and for that we can use serialization isolation level


# Let's begin a transaction and update the balance for Nancy


## ----- Session A
# Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;

# We see the balance is updated Nancy should have 0 balance


## ----- Session B
# Paste all commands in and just hit the play button to run all


BEGIN;


UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;


# We see the update statement is not completed
# The query runs for a long time till we commit the transaction in Session A


# Go back to Session A and commit

## ----- Session A
# Add this to the very bottom, select, and hit F5

COMMIT;


## ----- Session B

# Now check the query in Session B we see the query has run successfully
# This is because PostgreSQL places a lock to prevent another update until the first transaction is finished

# Now commit the second session's transaction (add this command to the very bottom, select, and run)

COMMIT;

SELECT * FROM bank_accounts;

# Now if we check Nancy's balance it is 10000 and not 0
# So the first transaction’s change is lost, because the second one “overwrote” the row


---------------

# To avoid this let's use serialization


## ----- Session A
# Paste all commands in and just hit the play button to run all

BEGIN;

UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;


# Here Nancy's balance should be 0



## ----- Session B
# Paste all commands in and just hit the play button to run all


BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';

SELECT * FROM bank_accounts;


# We see the query will not end

# Go back to Session A and commit

## ----- Session A
# Add this to the very bottom, select, and hit F5

COMMIT;


# Now check Session B and we see the query is not executed
# It throws error:
# ERROR:  could not serialize access due to concurrent update


























